// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

// Import store internals
import { IStore } from "@latticexyz/store/src/IStore.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { StoreCore } from "@latticexyz/store/src/StoreCore.sol";
import { Bytes } from "@latticexyz/store/src/Bytes.sol";
import { Memory } from "@latticexyz/store/src/Memory.sol";
import { SliceLib } from "@latticexyz/store/src/Slice.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import { FieldLayout } from "@latticexyz/store/src/FieldLayout.sol";
import { Schema } from "@latticexyz/store/src/Schema.sol";
import { EncodedLengths, EncodedLengthsLib } from "@latticexyz/store/src/EncodedLengths.sol";
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";

struct BuildMetadataData {
  uint256 submissionPrice;
  address[] builders;
  int16[] locationsX;
  int16[] locationsY;
  int16[] locationsZ;
}

library BuildMetadata {
  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: "buildanomics", name: "BuildMetadata", typeId: RESOURCE_TABLE });`
  ResourceId constant _tableId = ResourceId.wrap(0x74626275696c64616e6f6d69637300004275696c644d65746164617461000000);

  FieldLayout constant _fieldLayout =
    FieldLayout.wrap(0x0020010420000000000000000000000000000000000000000000000000000000);

  // Hex-encoded key schema of (bytes32)
  Schema constant _keySchema = Schema.wrap(0x002001005f000000000000000000000000000000000000000000000000000000);
  // Hex-encoded value schema of (uint256, address[], int16[], int16[], int16[])
  Schema constant _valueSchema = Schema.wrap(0x002001041fc38383830000000000000000000000000000000000000000000000);

  /**
   * @notice Get the table's key field names.
   * @return keyNames An array of strings with the names of key fields.
   */
  function getKeyNames() internal pure returns (string[] memory keyNames) {
    keyNames = new string[](1);
    keyNames[0] = "buildId";
  }

  /**
   * @notice Get the table's value field names.
   * @return fieldNames An array of strings with the names of value fields.
   */
  function getFieldNames() internal pure returns (string[] memory fieldNames) {
    fieldNames = new string[](5);
    fieldNames[0] = "submissionPrice";
    fieldNames[1] = "builders";
    fieldNames[2] = "locationsX";
    fieldNames[3] = "locationsY";
    fieldNames[4] = "locationsZ";
  }

  /**
   * @notice Register the table with its config.
   */
  function register() internal {
    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());
  }

  /**
   * @notice Register the table with its config.
   */
  function _register() internal {
    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());
  }

  /**
   * @notice Get submissionPrice.
   */
  function getSubmissionPrice(bytes32 buildId) internal view returns (uint256 submissionPrice) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes32 _blob = StoreSwitch.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Get submissionPrice.
   */
  function _getSubmissionPrice(bytes32 buildId) internal view returns (uint256 submissionPrice) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes32 _blob = StoreCore.getStaticField(_tableId, _keyTuple, 0, _fieldLayout);
    return (uint256(bytes32(_blob)));
  }

  /**
   * @notice Set submissionPrice.
   */
  function setSubmissionPrice(bytes32 buildId, uint256 submissionPrice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((submissionPrice)), _fieldLayout);
  }

  /**
   * @notice Set submissionPrice.
   */
  function _setSubmissionPrice(bytes32 buildId, uint256 submissionPrice) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((submissionPrice)), _fieldLayout);
  }

  /**
   * @notice Get builders.
   */
  function getBuilders(bytes32 buildId) internal view returns (address[] memory builders) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 0);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_address());
  }

  /**
   * @notice Get builders.
   */
  function _getBuilders(bytes32 buildId) internal view returns (address[] memory builders) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 0);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_address());
  }

  /**
   * @notice Set builders.
   */
  function setBuilders(bytes32 buildId, address[] memory builders) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((builders)));
  }

  /**
   * @notice Set builders.
   */
  function _setBuilders(bytes32 buildId, address[] memory builders) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 0, EncodeArray.encode((builders)));
  }

  /**
   * @notice Get the length of builders.
   */
  function lengthBuilders(bytes32 buildId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 0);
    unchecked {
      return _byteLength / 20;
    }
  }

  /**
   * @notice Get the length of builders.
   */
  function _lengthBuilders(bytes32 buildId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 0);
    unchecked {
      return _byteLength / 20;
    }
  }

  /**
   * @notice Get an item of builders.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemBuilders(bytes32 buildId, uint256 _index) internal view returns (address) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 20, (_index + 1) * 20);
      return (address(bytes20(_blob)));
    }
  }

  /**
   * @notice Get an item of builders.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemBuilders(bytes32 buildId, uint256 _index) internal view returns (address) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 0, _index * 20, (_index + 1) * 20);
      return (address(bytes20(_blob)));
    }
  }

  /**
   * @notice Push an element to builders.
   */
  function pushBuilders(bytes32 buildId, address _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));
  }

  /**
   * @notice Push an element to builders.
   */
  function _pushBuilders(bytes32 buildId, address _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 0, abi.encodePacked((_element)));
  }

  /**
   * @notice Pop an element from builders.
   */
  function popBuilders(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 0, 20);
  }

  /**
   * @notice Pop an element from builders.
   */
  function _popBuilders(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 0, 20);
  }

  /**
   * @notice Update an element of builders at `_index`.
   */
  function updateBuilders(bytes32 buildId, uint256 _index, address _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 20), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update an element of builders at `_index`.
   */
  function _updateBuilders(bytes32 buildId, uint256 _index, address _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 0, uint40(_index * 20), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get locationsX.
   */
  function getLocationsX(bytes32 buildId) internal view returns (int16[] memory locationsX) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 1);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_int16());
  }

  /**
   * @notice Get locationsX.
   */
  function _getLocationsX(bytes32 buildId) internal view returns (int16[] memory locationsX) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 1);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_int16());
  }

  /**
   * @notice Set locationsX.
   */
  function setLocationsX(bytes32 buildId, int16[] memory locationsX) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 1, EncodeArray.encode((locationsX)));
  }

  /**
   * @notice Set locationsX.
   */
  function _setLocationsX(bytes32 buildId, int16[] memory locationsX) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 1, EncodeArray.encode((locationsX)));
  }

  /**
   * @notice Get the length of locationsX.
   */
  function lengthLocationsX(bytes32 buildId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 1);
    unchecked {
      return _byteLength / 2;
    }
  }

  /**
   * @notice Get the length of locationsX.
   */
  function _lengthLocationsX(bytes32 buildId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 1);
    unchecked {
      return _byteLength / 2;
    }
  }

  /**
   * @notice Get an item of locationsX.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemLocationsX(bytes32 buildId, uint256 _index) internal view returns (int16) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 2, (_index + 1) * 2);
      return (int16(uint16(bytes2(_blob))));
    }
  }

  /**
   * @notice Get an item of locationsX.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemLocationsX(bytes32 buildId, uint256 _index) internal view returns (int16) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 1, _index * 2, (_index + 1) * 2);
      return (int16(uint16(bytes2(_blob))));
    }
  }

  /**
   * @notice Push an element to locationsX.
   */
  function pushLocationsX(bytes32 buildId, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 1, abi.encodePacked((_element)));
  }

  /**
   * @notice Push an element to locationsX.
   */
  function _pushLocationsX(bytes32 buildId, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 1, abi.encodePacked((_element)));
  }

  /**
   * @notice Pop an element from locationsX.
   */
  function popLocationsX(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 1, 2);
  }

  /**
   * @notice Pop an element from locationsX.
   */
  function _popLocationsX(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 1, 2);
  }

  /**
   * @notice Update an element of locationsX at `_index`.
   */
  function updateLocationsX(bytes32 buildId, uint256 _index, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 2), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update an element of locationsX at `_index`.
   */
  function _updateLocationsX(bytes32 buildId, uint256 _index, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 1, uint40(_index * 2), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get locationsY.
   */
  function getLocationsY(bytes32 buildId) internal view returns (int16[] memory locationsY) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 2);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_int16());
  }

  /**
   * @notice Get locationsY.
   */
  function _getLocationsY(bytes32 buildId) internal view returns (int16[] memory locationsY) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 2);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_int16());
  }

  /**
   * @notice Set locationsY.
   */
  function setLocationsY(bytes32 buildId, int16[] memory locationsY) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 2, EncodeArray.encode((locationsY)));
  }

  /**
   * @notice Set locationsY.
   */
  function _setLocationsY(bytes32 buildId, int16[] memory locationsY) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 2, EncodeArray.encode((locationsY)));
  }

  /**
   * @notice Get the length of locationsY.
   */
  function lengthLocationsY(bytes32 buildId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 2);
    unchecked {
      return _byteLength / 2;
    }
  }

  /**
   * @notice Get the length of locationsY.
   */
  function _lengthLocationsY(bytes32 buildId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 2);
    unchecked {
      return _byteLength / 2;
    }
  }

  /**
   * @notice Get an item of locationsY.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemLocationsY(bytes32 buildId, uint256 _index) internal view returns (int16) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 2, _index * 2, (_index + 1) * 2);
      return (int16(uint16(bytes2(_blob))));
    }
  }

  /**
   * @notice Get an item of locationsY.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemLocationsY(bytes32 buildId, uint256 _index) internal view returns (int16) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 2, _index * 2, (_index + 1) * 2);
      return (int16(uint16(bytes2(_blob))));
    }
  }

  /**
   * @notice Push an element to locationsY.
   */
  function pushLocationsY(bytes32 buildId, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 2, abi.encodePacked((_element)));
  }

  /**
   * @notice Push an element to locationsY.
   */
  function _pushLocationsY(bytes32 buildId, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 2, abi.encodePacked((_element)));
  }

  /**
   * @notice Pop an element from locationsY.
   */
  function popLocationsY(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 2, 2);
  }

  /**
   * @notice Pop an element from locationsY.
   */
  function _popLocationsY(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 2, 2);
  }

  /**
   * @notice Update an element of locationsY at `_index`.
   */
  function updateLocationsY(bytes32 buildId, uint256 _index, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 2, uint40(_index * 2), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update an element of locationsY at `_index`.
   */
  function _updateLocationsY(bytes32 buildId, uint256 _index, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 2, uint40(_index * 2), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get locationsZ.
   */
  function getLocationsZ(bytes32 buildId) internal view returns (int16[] memory locationsZ) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes memory _blob = StoreSwitch.getDynamicField(_tableId, _keyTuple, 3);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_int16());
  }

  /**
   * @notice Get locationsZ.
   */
  function _getLocationsZ(bytes32 buildId) internal view returns (int16[] memory locationsZ) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    bytes memory _blob = StoreCore.getDynamicField(_tableId, _keyTuple, 3);
    return (SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_int16());
  }

  /**
   * @notice Set locationsZ.
   */
  function setLocationsZ(bytes32 buildId, int16[] memory locationsZ) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.setDynamicField(_tableId, _keyTuple, 3, EncodeArray.encode((locationsZ)));
  }

  /**
   * @notice Set locationsZ.
   */
  function _setLocationsZ(bytes32 buildId, int16[] memory locationsZ) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.setDynamicField(_tableId, _keyTuple, 3, EncodeArray.encode((locationsZ)));
  }

  /**
   * @notice Get the length of locationsZ.
   */
  function lengthLocationsZ(bytes32 buildId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    uint256 _byteLength = StoreSwitch.getDynamicFieldLength(_tableId, _keyTuple, 3);
    unchecked {
      return _byteLength / 2;
    }
  }

  /**
   * @notice Get the length of locationsZ.
   */
  function _lengthLocationsZ(bytes32 buildId) internal view returns (uint256) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    uint256 _byteLength = StoreCore.getDynamicFieldLength(_tableId, _keyTuple, 3);
    unchecked {
      return _byteLength / 2;
    }
  }

  /**
   * @notice Get an item of locationsZ.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function getItemLocationsZ(bytes32 buildId, uint256 _index) internal view returns (int16) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _blob = StoreSwitch.getDynamicFieldSlice(_tableId, _keyTuple, 3, _index * 2, (_index + 1) * 2);
      return (int16(uint16(bytes2(_blob))));
    }
  }

  /**
   * @notice Get an item of locationsZ.
   * @dev Reverts with Store_IndexOutOfBounds if `_index` is out of bounds for the array.
   */
  function _getItemLocationsZ(bytes32 buildId, uint256 _index) internal view returns (int16) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _blob = StoreCore.getDynamicFieldSlice(_tableId, _keyTuple, 3, _index * 2, (_index + 1) * 2);
      return (int16(uint16(bytes2(_blob))));
    }
  }

  /**
   * @notice Push an element to locationsZ.
   */
  function pushLocationsZ(bytes32 buildId, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.pushToDynamicField(_tableId, _keyTuple, 3, abi.encodePacked((_element)));
  }

  /**
   * @notice Push an element to locationsZ.
   */
  function _pushLocationsZ(bytes32 buildId, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.pushToDynamicField(_tableId, _keyTuple, 3, abi.encodePacked((_element)));
  }

  /**
   * @notice Pop an element from locationsZ.
   */
  function popLocationsZ(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.popFromDynamicField(_tableId, _keyTuple, 3, 2);
  }

  /**
   * @notice Pop an element from locationsZ.
   */
  function _popLocationsZ(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.popFromDynamicField(_tableId, _keyTuple, 3, 2);
  }

  /**
   * @notice Update an element of locationsZ at `_index`.
   */
  function updateLocationsZ(bytes32 buildId, uint256 _index, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreSwitch.spliceDynamicData(_tableId, _keyTuple, 3, uint40(_index * 2), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Update an element of locationsZ at `_index`.
   */
  function _updateLocationsZ(bytes32 buildId, uint256 _index, int16 _element) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    unchecked {
      bytes memory _encoded = abi.encodePacked((_element));
      StoreCore.spliceDynamicData(_tableId, _keyTuple, 3, uint40(_index * 2), uint40(_encoded.length), _encoded);
    }
  }

  /**
   * @notice Get the full data.
   */
  function get(bytes32 buildId) internal view returns (BuildMetadataData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    (bytes memory _staticData, EncodedLengths _encodedLengths, bytes memory _dynamicData) = StoreSwitch.getRecord(
      _tableId,
      _keyTuple,
      _fieldLayout
    );
    return decode(_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Get the full data.
   */
  function _get(bytes32 buildId) internal view returns (BuildMetadataData memory _table) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    (bytes memory _staticData, EncodedLengths _encodedLengths, bytes memory _dynamicData) = StoreCore.getRecord(
      _tableId,
      _keyTuple,
      _fieldLayout
    );
    return decode(_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using individual values.
   */
  function set(
    bytes32 buildId,
    uint256 submissionPrice,
    address[] memory builders,
    int16[] memory locationsX,
    int16[] memory locationsY,
    int16[] memory locationsZ
  ) internal {
    bytes memory _staticData = encodeStatic(submissionPrice);

    EncodedLengths _encodedLengths = encodeLengths(builders, locationsX, locationsY, locationsZ);
    bytes memory _dynamicData = encodeDynamic(builders, locationsX, locationsY, locationsZ);

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using individual values.
   */
  function _set(
    bytes32 buildId,
    uint256 submissionPrice,
    address[] memory builders,
    int16[] memory locationsX,
    int16[] memory locationsY,
    int16[] memory locationsZ
  ) internal {
    bytes memory _staticData = encodeStatic(submissionPrice);

    EncodedLengths _encodedLengths = encodeLengths(builders, locationsX, locationsY, locationsZ);
    bytes memory _dynamicData = encodeDynamic(builders, locationsX, locationsY, locationsZ);

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);
  }

  /**
   * @notice Set the full data using the data struct.
   */
  function set(bytes32 buildId, BuildMetadataData memory _table) internal {
    bytes memory _staticData = encodeStatic(_table.submissionPrice);

    EncodedLengths _encodedLengths = encodeLengths(
      _table.builders,
      _table.locationsX,
      _table.locationsY,
      _table.locationsZ
    );
    bytes memory _dynamicData = encodeDynamic(_table.builders, _table.locationsX, _table.locationsY, _table.locationsZ);

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using the data struct.
   */
  function _set(bytes32 buildId, BuildMetadataData memory _table) internal {
    bytes memory _staticData = encodeStatic(_table.submissionPrice);

    EncodedLengths _encodedLengths = encodeLengths(
      _table.builders,
      _table.locationsX,
      _table.locationsY,
      _table.locationsZ
    );
    bytes memory _dynamicData = encodeDynamic(_table.builders, _table.locationsX, _table.locationsY, _table.locationsZ);

    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);
  }

  /**
   * @notice Decode the tightly packed blob of static data using this table's field layout.
   */
  function decodeStatic(bytes memory _blob) internal pure returns (uint256 submissionPrice) {
    submissionPrice = (uint256(Bytes.getBytes32(_blob, 0)));
  }

  /**
   * @notice Decode the tightly packed blob of dynamic data using the encoded lengths.
   */
  function decodeDynamic(
    EncodedLengths _encodedLengths,
    bytes memory _blob
  )
    internal
    pure
    returns (address[] memory builders, int16[] memory locationsX, int16[] memory locationsY, int16[] memory locationsZ)
  {
    uint256 _start;
    uint256 _end;
    unchecked {
      _end = _encodedLengths.atIndex(0);
    }
    builders = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_address());

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(1);
    }
    locationsX = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_int16());

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(2);
    }
    locationsY = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_int16());

    _start = _end;
    unchecked {
      _end += _encodedLengths.atIndex(3);
    }
    locationsZ = (SliceLib.getSubslice(_blob, _start, _end).decodeArray_int16());
  }

  /**
   * @notice Decode the tightly packed blobs using this table's field layout.
   * @param _staticData Tightly packed static fields.
   * @param _encodedLengths Encoded lengths of dynamic fields.
   * @param _dynamicData Tightly packed dynamic fields.
   */
  function decode(
    bytes memory _staticData,
    EncodedLengths _encodedLengths,
    bytes memory _dynamicData
  ) internal pure returns (BuildMetadataData memory _table) {
    (_table.submissionPrice) = decodeStatic(_staticData);

    (_table.builders, _table.locationsX, _table.locationsY, _table.locationsZ) = decodeDynamic(
      _encodedLengths,
      _dynamicData
    );
  }

  /**
   * @notice Delete all data for given keys.
   */
  function deleteRecord(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreSwitch.deleteRecord(_tableId, _keyTuple);
  }

  /**
   * @notice Delete all data for given keys.
   */
  function _deleteRecord(bytes32 buildId) internal {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);
  }

  /**
   * @notice Tightly pack static (fixed length) data using this table's schema.
   * @return The static data, encoded into a sequence of bytes.
   */
  function encodeStatic(uint256 submissionPrice) internal pure returns (bytes memory) {
    return abi.encodePacked(submissionPrice);
  }

  /**
   * @notice Tightly pack dynamic data lengths using this table's schema.
   * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).
   */
  function encodeLengths(
    address[] memory builders,
    int16[] memory locationsX,
    int16[] memory locationsY,
    int16[] memory locationsZ
  ) internal pure returns (EncodedLengths _encodedLengths) {
    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits
    unchecked {
      _encodedLengths = EncodedLengthsLib.pack(
        builders.length * 20,
        locationsX.length * 2,
        locationsY.length * 2,
        locationsZ.length * 2
      );
    }
  }

  /**
   * @notice Tightly pack dynamic (variable length) data using this table's schema.
   * @return The dynamic data, encoded into a sequence of bytes.
   */
  function encodeDynamic(
    address[] memory builders,
    int16[] memory locationsX,
    int16[] memory locationsY,
    int16[] memory locationsZ
  ) internal pure returns (bytes memory) {
    return
      abi.encodePacked(
        EncodeArray.encode((builders)),
        EncodeArray.encode((locationsX)),
        EncodeArray.encode((locationsY)),
        EncodeArray.encode((locationsZ))
      );
  }

  /**
   * @notice Encode all of a record's fields.
   * @return The static (fixed length) data, encoded into a sequence of bytes.
   * @return The lengths of the dynamic fields (packed into a single bytes32 value).
   * @return The dynamic (variable length) data, encoded into a sequence of bytes.
   */
  function encode(
    uint256 submissionPrice,
    address[] memory builders,
    int16[] memory locationsX,
    int16[] memory locationsY,
    int16[] memory locationsZ
  ) internal pure returns (bytes memory, EncodedLengths, bytes memory) {
    bytes memory _staticData = encodeStatic(submissionPrice);

    EncodedLengths _encodedLengths = encodeLengths(builders, locationsX, locationsY, locationsZ);
    bytes memory _dynamicData = encodeDynamic(builders, locationsX, locationsY, locationsZ);

    return (_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Encode keys as a bytes32 array using this table's field layout.
   */
  function encodeKeyTuple(bytes32 buildId) internal pure returns (bytes32[] memory) {
    bytes32[] memory _keyTuple = new bytes32[](1);
    _keyTuple[0] = buildId;

    return _keyTuple;
  }
}
